---
title: 两种函数组合方式
date: 2019-06-20
categories: 
  - 前端
---

> 这里所说的组合方式，指的是将多个函数通过某种方式排布起来，通过一次调用，就能调用所有函数的形式

## compose实现形式

compose的实现形式中，通过将所有函数传递到compose函数，经过compose处理以后得到一个组合函数，形式如下

```js
 var fn = compose(fn1, fn2...)
```

<!-- more -->

下面是关于compose的实现

```js
    function compose(...funcs){
        return funcs.reduce((a, b) => data => b(a(data)))
    }
```

compose返回了一个通过reduce归并之后的方法，可以看到在这个方法中，会先调用位置靠前函数(当然也可以反过来)，并将结果返回到下一个函数

写几个测试函数

```js
function fn1(obj){
    console.log('fn1')
    return obj
}

function fn2(obj){
    console.log('fn2')
    return obj
}

function fn3(obj){
    console.log('fn3')
    return obj
}
```

在这里，并没有对数据做任何操作，只是简单的打印了一下方法名。通过compose组合之后看看效果

```js
const com = compose(fn1, fn2, fn3)

com(1)
```

> 输出结果：  
fn1  
fn2  
fn3

当然在compose中，还有很多地方需要优化，比如过滤非function的参数，以及参数的传递。同时，可以看到，方法之间都存在参数关联的问题，也就是后一个函数的参数是依前一个函数的返回值，所以这种情况下，一般我们会要求传递给compose的函数，以及compose组合后的函数所调用的参数，还有返回值是统一类型的数据，比如都是FormData数据，都是BUffer等等，其实原因也显而易见

许多优秀的库都采用这种形式，比如[`recompose`](https://github.com/acdlite/recompose/blob/master/src/packages/recompose/compose.js)、[`redux`](https://github.com/reduxjs/redux/blob/master/src/compose.js)中的compose函数都是这种形式

## axios拦截器实现

axios拦截器是实现原理是将数据Promise化，通过Promise的链式调用的特性来链式调用传递进去的函数

先贴上axios关于这部分的源码：

```js
var chain = [dispatchRequest, undefined];
var promise = Promise.resolve(config);

this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
});

this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
});

while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
}

return promise;
```

`this.interceptors.request`和`this.interceptors.response`都是一个拦截器对象，通过内部实现的forEach方法可以迭代出通过use方法传递的函数

我们注意到几点：

1、 request的函数是通过unshift添加到数组前面，因此调用的时候，是与传入的顺序相反

2、 response的函数在数组后面

3、 每一个拦截器都有resolve和reject状态的函数，或者是undefined

因此,promise的执行顺序是，逆序执行通过request.use传递进来的函数，此时，每一个状态下都接受和返回config。当执行到dispatchRequest之后，dispatchRequest返回的数据是response，因此对于响应拦截器而言，接受和返回的就是response

## 总结

2种实现方法都有各自的优势和不足，compose实现原理简单，但可以看到需要约束方法接受和返回的数据，而promise的实现方式更为优雅。compose往往用于加载中间件函数来增强功能，不过promise也基本可以替代compose。