---
title: 收集的部分问题及解决方法
date: 2019-07-09
categories:
  - 前端
tags: 
  - js
  - ts
---

## 1、has no compatible call signatures

出现这个问题的原因是在变量声明期间没有给变量声明对应的类型，尤其是数组或者对象，这样在使用的时候回导致无法检测到要用的字段

- 解决方案一
  在声明的时候就写上类型
```typescript
const data: Array<{isOk: boolean}> = somefunction()
data.filter(item => item.isOk)
```
- 解决方案二
  在使用的时候通过类型断言来声明要使用的字段
```typescript
const data = somefunction()
(data as Array<{isOk: boolean}>).filter(item => item.isOk)
// 或者
(<{isOk: boolean}[]>data).filter(item => item.isOk)
```

## 2、声明带类型的方法类型

声明方法类型如下：

```typescript
interface Fun{
    (arg): void 
}
// 或者

type Fun2 = (args) => void
```

如果声明的方法带有类型可以这样做

1、在类型前面加泛型
```typescript
type Fun2 = <T>(args: Array<T>) => T
```
这样可以直接给变量声明这个类型
```typescript
let func: Fun2 = (arr) =>{
    return arr[0]
}
```
typescript会自动探测传递到arr中的数据的类型，就像这样使用

```typescript
func([1,2,3])
```

2、 将泛型类型暴露给方法类型
```typescript
type Fun2<T> = (args: Array<T>) => T

let func: Fun2<number> = (arr) =>{
    return arr[0]
}
```
这样就相当于强制要求arr只能接受数字类型的数组

这两者的不同之处在于，第二种形式里面，可以强制要求调用者传递某种类型的参数

**以上就是声明带泛型的方法类型**