---
title: 单例模式
date: "2021-08-26 23:18:07"
categories:
  - python
lang: zh-cn
---

## 方式一：通过 new 创建

重写类的`__new__方法`来实现

```python
class Modal(object):
    instance = None

    @classmethod
    def __new__(cls, *args, **kwargs):
        if cls.instance is None:
            cls.instance = super().__new__(*args, **kwargs)
            # cls.instance = super(Modal, cls).__new__(*args, **kwargs)
            # cls.instance = object.__new__(*args, **kwargs)
        return cls.instance

    def __init__(self):
        print('初始化')
        self.count = 1

m1 = Modal()
m2 = Modal()
print(m1 is m2)
```

> 需要注意的是：每次创建的时候，虽然返回的都是同一个对象，但是`__init__`都会执行，所以在这里面初始化的对象属性都会被重新初始化

<!-- more -->

## 方式二：装饰器

首先定义装饰器

```python
def signal(cls):
    instance = None

    def c(*args, **kwargs):
        nonlocal instance
        if not instance:
            instance = cls(*args, **kwargs)
        return instance
    return c
```

然后在作用于类上

```python
@signal
class Modal:
    pass
```

> 这种模式的优点是，做到了逻辑的抽离，对类的侵入较小

> 缺点是在类上定义的`classmethod`和`staticmethod`，无法访问到

## 方式三：使用类方法

类似于方法一，只不过自定义了一个类方法来完成`__new__`的工作
