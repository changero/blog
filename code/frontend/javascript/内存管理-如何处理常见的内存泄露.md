---
title: 内存管理-如何处理常见的内存泄露
date: '2022-04-05 21:13:03'
categories:
  - javascript
tags:
  - js工作原理
lang: zh-cn
---

## 概述

语言（如 C 语言）具有低级内存管理基元，开发人员使用`malloc()`和`free()`方法显示的分配和释放内存单元

同样，在 javascript 中，在创建对象时分配内存， 并在不再使用的时候释放内存，这个过程被称为垃圾回收。这种释放资源的看似"自动"的性质是混乱的根源，并给 JavaScript（和其他高级语言）开发人员留下了他们可以选择不关心内存管理的错误印象，**这是一个很大的错误**。

即使在使用高级语言时，开发人员也应该了解内存管理（或至少是基础知识）。有时，自动内存管理存在问题（例如垃圾回收器中的错误或实现限制等），开发人员必须了解这些问题才能正确处理它们（或找到适当的解决方法，同时以最小的权衡和代码债务）。

## 内存生命周期

论您使用哪种编程语言，内存生命周期几乎总是相同的：

<c-img src="https://miro.medium.com/max/1400/1*slxXgq_TO38TgtoKpWa_jQ.png" />

<!-- more -->

以下是周期中每个步骤中发生的情况的概述：

- 分配内存 — 内存由操作系统分配，它允许您的程序使用它。在低级语言（例如.C）中，这是您作为开发人员应该处理的显式操作。但是，在高级语言中，这是为您处理的。
- 使用内存 — 这是程序实际使用以前分配的内存的时间。当您在代码中使用分配的变量时，将执行读取和写入操作。
- 释放内存 - 现在是时候释放您不需要的整个内存，以便它可以变得可用并再次可用。与"分配内存"操作一样，此操作在低级语言中是显式的。

## 什么是内存

在硬件级别上，计算机内存由大量触发器组成，每个触发器包含几个晶体管，能够存储一个位。单个触发器可通过唯一标识符寻址，因此我们可以读取并覆盖它们。因此，从概念上讲，我们可以将整个计算机内存视为一个可以读取和写入的巨型位数组。

由于作为人类，我们不擅长以比特为单位进行所有思考和算术，因此我们将它们组织成更大的组，这些组一起可以用来表示数字。8 位称为 1 字节。除了字节之外，还有单词（有时是 16 位，有时是 32 位）。

很多东西都存储在这个内存中：

1. 所有程序使用的所有变量和其他数据。
2. 程序的代码，包括操作系统的代码。

编译器和操作系统协同工作，为您处理大部分内存管理，但我们建议您查看后台发生的情况。

编译代码时，编译器可以检查基元数据类型并提前计算它们需要多少内存。然后，在调用堆栈空间中将所需的量分配给程序。分配这些变量的空间称为堆栈空间，因为当函数被调用时，它们的内存被添加到现有内存之上。当它们终止时，它们将按照后进先出（后进先出）顺序移除。例如，请考虑以下声明：

```c
int n; // 4 bytes
int x[4]; // array of 4 elements, each 4 bytes
double m; // 8 bytes
```

编译器可以立即看到代码需要`4 + 4 × 4 + 8 = 28` 字节。

> 这就是它如何处理整数和双精度的当前大小。大约 20 年前，整数通常为 2 个字节，双倍为 4 个字节。您的代码永远不必依赖于目前基本数据类型的大小。

编译器将插入将与操作系统交互的代码，以请求堆栈上存储变量所需的字节数。

在上面的示例中，编译器知道每个变量的确切内存地址。实际上，每当我们写入变量时，这都会在内部转换为"memory address 4127963"之类的东西

请注意，如果我们尝试访问此处，我们将访问与 m 关联的数据。这是因为我们正在访问数组中不存在的元素 - 它比数组中最后一个实际分配的元素远 4 个字节，并且可能最终读取（或覆盖）某些位。这几乎肯定会对程序的其余部分产生非常不良的后果。

<c-img src="https://miro.medium.com/max/1400/1*5aBou4onl1B8xlgwoGTDOg.png" />

当函数调用其他函数时，每个函数在调用时都会获得自己的堆栈块。它保留了所有局部变量，但也有一个程序计数器，可以记住它在执行中的位置。当函数完成时，其内存块将再次可用于其他目的。

## 动态分配

不幸的是，当我们在编译时不知道变量需要多少内存时，事情就不那么容易了。假设我们要执行如下操作：

```c
int n = readInput(); // reads input from the user
...
// create an array with "n" elements
```

在这里，在编译时，编译器不知道数组需要多少内存，因为它是由用户提供的值决定的。因此，它无法为堆栈上的变量分配空间。相反，我们的程序需要在运行时显式要求操作系统提供适当的空间量。此内存是从堆空间中分配的

## javascript 中的内存分配

现在，我们将解释第一步（分配内存）在 JavaScript 中的工作原理。

JavaScript 将开发人员从处理内存分配的责任中解脱出来 — JavaScript 在声明值的同时，自己完成它。

```js
var n = 374; // allocates memory for a number
var s = 'sessionstack'; // allocates memory for a string
var o = {
  a: 1,
  b: null,
}; // allocates memory for an object and its contained values
var a = [1, null, 'str']; // (like object) allocates memory for the
// array and its contained values
function f(a) {
  return a + 3;
} // allocates a function (which is a callable object)
// function expressions also allocate an object
someElement.addEventListener(
  'click',
  function() {
    someElement.style.backgroundColor = 'blue';
  },
  false
);
```

某些函数调用也会导致对象分配：

```js
var d = new Date(); // allocates a Date object
var e = document.createElement('div'); // allocates a DOM element
```

方法可以分配新的值或对象：

```js
var s1 = 'sessionstack';
var s2 = s1.substr(0, 3); // s2 is a new string
// Since strings are immutable,
// JavaScript may decide to not allocate memory,
// but just store the [0, 3] range.
var a1 = ['str1', 'str2'];
var a2 = ['str3', 'str4'];
var a3 = a1.concat(a2);
// new array with 4 elements being
// the concatenation of a1 and a2 elements
```

基本上，在 JavaScript 中使用分配的内存意味着在其中读取和写入。

这可以通过读取或写入变量或对象属性的值，甚至将参数传递给函数来完成

### 不再需要内存时释放

大多数内存管理问题都出现在此阶段。

这里最困难的任务是弄清楚何时不再需要分配的内存。它通常需要开发人员确定在程序中不再需要此类内存的位置并释放它。

高级语言嵌入了一个名为**垃圾回收器**的软件，其工作是跟踪内存分配和使用，以便查找何时不再需要分配的内存，在这种情况下，它将自动释放它。

大多数垃圾回收器通过收集无法再访问的内存来工作，例如，指向它的所有变量都超出了范围。但是，这是对可以收集的内存空间集的低估，因为在任何时候，内存位置可能仍然有一个变量指向作用域中，但永远不会再次访问它。

### 垃圾回收

由于无法确定是否"不再需要"某些内存，因此垃圾回收实现了对一般问题的解决方案的限制。本节将解释了解主要垃圾回收算法及其局限性的必要概念

### 内存引用

垃圾回收算法所依赖的主要概念是参考。

在内存管理的上下文中，如果一个对象有权访问后者（可以是隐式或显式的），则称一个对象引用另一个对象。例如，JavaScript 对象具有对其原型（隐式引用）及其属性值（显式引用）的引用。

在此上下文中，"对象"的概念扩展到比常规 JavaScript 对象更广泛的内容，并且还包含函数作用域（或全局词法作用域）。

> 词法范围定义了如何在嵌套函数中解析变量名称：内部函数包含父函数的作用域，即使父函数已返回也是如此。

### 引用计数垃圾回收

这是最简单的垃圾回收算法。如果某个对象没有指向该对象的引用，则该对象被视为"可垃圾回收"。

```js
var o1 = {
  o2: {
    x: 1,
  },
};
// 2 objects are created.
// 'o2' is referenced by 'o1' object as one of its properties.
// None can be garbage-collected

var o3 = o1; // the 'o3' variable is the second thing that
// has a reference to the object pointed by 'o1'.

o1 = 1; // now, the object that was originally in 'o1' has a
// single reference, embodied by the 'o3' variable

var o4 = o3.o2; // reference to 'o2' property of the object.
// This object has now 2 references: one as
// a property.
// The other as the 'o4' variable

o3 = '374'; // The object that was originally in 'o1' has now zero
// references to it.
// It can be garbage-collected.
// However, what was its 'o2' property is still
// referenced by the 'o4' variable, so it cannot be
// freed.

o4 = null; // what was the 'o2' property of the object originally in
// 'o1' has zero references to it.
// It can be garbage collected.
```

### 周期正在制造问题

在周期方面存在局限性。在下面的示例中，创建了两个对象并相互引用，从而创建了一个循环。它们在函数调用后将超出范围，因此它们实际上是无用的，并且可以被释放。但是，引用计数算法认为，由于两个对象中的每一个都至少被引用一次，因此两者都不能被垃圾回收。

```js
function f() {
  var o1 = {};
  var o2 = {};
  o1.p = o2; // o1 references o2
  o2.p = o1; // o2 references o1. This creates a cycle.
}

f();
```

<c-img src="https://miro.medium.com/max/772/1*GF3p99CQPZkX3UkgyVKSHw.png" />

### 标记和扫描算法

为了确定是否需要某个对象，此算法确定该对象是否可访问。

标记和扫描算法执行以下 3 个步骤：

1. 根：通常，根是在代码中引用的全局变量。例如，在 JavaScript 中，可以充当根的全局变量是"窗口"对象。Node.js 中的相同对象称为"全局"。垃圾回收器会构建所有根的完整列表。
2. 然后，该算法检查所有根及其子根，并将它们标记为活动根（这意味着，它们不是垃圾）。根无法访问的任何内容都将被标记为垃圾。
3. 最后，垃圾回收器释放所有未标记为活动状态的内存片段，并将该内存返回到操作系统。

<c-img src="https://miro.medium.com/max/1400/1*WVtok3BV0NgU95mpxk9CNg.gif" />

此算法比前一个算法更好，因为"对象引用为零"导致此对象无法访问。相反，正如我们在周期中看到的那样。

截至 2012 年，所有现代浏览器都提供了标记和扫描垃圾收集器。在过去几年中，在 JavaScript 垃圾回收领域所做的所有改进（生成/增量/并发/并行垃圾回收）都是此算法的实现改进（标记和扫描），但不是对垃圾回收算法本身的改进，也不是其决定对象是否可访问的目标。

### 周期不再是问题

在上面的第一个示例中，函数调用返回后，全局对象可访问的内容不再引用这两个对象。因此，垃圾回收器将发现它们无法访问。

<c-img src="https://miro.medium.com/max/1400/1*FbbOG9mcqWZtNajjDO6SaA.png" />

即使对象之间存在引用，也无法从根访问它们。

### 垃圾回收器的反直觉行为

尽管垃圾收集器很方便，但它们有自己的一套权衡。其中之一是非决定论。换句话说，指导性案例是不可预测的。您无法真正知道何时执行收集。这意味着在某些情况下，程序使用的内存比实际需要的内存更多。在其他情况下，在特别敏感的应用程序中，短暂停可能会很明显。尽管非确定性意味着无法确定何时执行收集，但大多数 GC 实现都共享在分配期间执行收集传递的常见模式。如果未执行任何分配，则大多数 GC 将保持空闲状态。请考虑以下方案：

1. 执行一组相当大的分配。
2. 这些元素中的大多数（或全部）都被标记为无法访问（假设我们将指向不再需要的缓存的引用清空）。
3. 不执行进一步的分配。

在这种情况下，大多数 GC 将不再运行任何进一步的收集过程。换句话说，即使有无法访问的参考资料可供收集，收藏家也不会声称这些参考资料。这些不是严格的泄漏，但仍然会导致高于平常的内存使用率。

### 什么是内存泄漏？

正如内存所暗示的那样，内存泄漏是应用程序过去使用过但不再需要但尚未返回到操作系统或可用内存池的内存片段。

<c-img src="https://miro.medium.com/max/900/1*0B-dAUOH7NrcCDP6GhKHQw.jpeg" />

编程语言倾向于不同的内存管理方式。但是，是否使用某段内存实际上是一个无法判定的问题。换句话说，只有开发人员才能明确一段内存是否可以返回到操作系统。

某些编程语言提供了帮助开发人员执行此操作的功能。其他人则希望开发人员完全明确一段内存何时未被使用。维基百科有关于[手动](https://en.wikipedia.org/wiki/Manual_memory_management)和[自动](<https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)>)内存管理的好文章。

## 常见的四种类型的 JavaScript 泄漏

### 全局变量

JavaScript 以一种有趣的方式处理未声明的变量：当引用未声明的变量时，将在全局对象中创建一个新变量。在浏览器中，全局对象将是 ，这意味着 window

```js
function foo(arg) {
  bar = 'some text';
}
```

相当于

```js
function foo(arg) {
  window.bar = 'some text';
}
```

假设 的目的是仅引用 foo 函数中的变量。但是，如果不使用冗余全局变量来声明它，则将创建它。在上述情况下，这不会造成太大的伤害。不过，您肯定可以想象一个更具破坏性的场景

您还可以使用以下命令意外创建全局变量：this

```js
function foo() {
  this.var1 = 'potential accidental global';
}
// Foo called on its own, this points to the global object (window)
// rather than being undefined.
foo();
```

> 您可以通过在 JavaScript 文件的开头添加来避免所有这些，这将打开更严格的 JavaScript 解析模式，从而防止意外创建全局变量。‘use strict’;

意外的全局变量肯定是一个问题，但是，您的代码通常会受到显式全局变量的侵扰，根据定义，垃圾回收器无法收集这些变量。需要特别注意用于临时存储和处理大量信息的全局变量。如果必须，请使用全局变量来存储数据，但当您这样做时，请确保将其指定为 null 或在完成后重新分配它。

### 定时器

让我们以 JavaScript 中经常使用为例。`setInterval`

提供观察器的库和其他接受回调的仪器通常确保，一旦其实例也无法访问，则对回调的所有引用都变得不可访问。不过，下面的代码并不罕见：

```js
var serverData = loadData();
setInterval(function() {
  var renderer = document.getElementById('renderer');
  if (renderer) {
    renderer.innerHTML = JSON.stringify(serverData);
  }
}, 5000); //This will be executed every ~5 seconds.
```

上面的代码段显示了使用引用不再需要的节点或数据的计时器的后果。

该对象可能会在某个时刻被替换或删除，这将使间隔处理程序封装的块变得多余。如果发生这种情况，则不会收集处理程序及其依赖项，因为需要首先停止间隔（请记住，它仍处于活动状态）。这一切都归结为这样一个事实，即肯定会存储和处理大量数据的数据也不会被收集。

使用观察器时，您需要确保在完成观察器操作后进行显式调用以将其删除（要么不再需要观察者，要么对象将变得无法访问）。

幸运的是，大多数现代浏览器都可以为您完成这项工作：一旦观察到的对象变得无法访问，即使您忘记删除侦听器，它们也会自动收集观察者处理程序。过去，一些浏览器无法处理这些情况（旧的 IE6）。

不过，一旦对象过时，删除观察器仍然符合最佳实践。请参阅以下示例：

```js
var element = document.getElementById('launch-button');
var counter = 0;
function onClick(event) {
  counter++;
  element.innerHtml = 'text ' + counter;
}
element.addEventListener('click', onClick);
// Do stuff
element.removeEventListener('click', onClick);
element.parentNode.removeChild(element);
// Now when element goes out of scope,
// both element and onClick will be collected even in old browsers // that don't handle cycles well.
```

在使节点无法访问之前，您不再需要调用，因为现代浏览器支持垃圾回收器，可以检测这些循环并适当地处理它们。removeEventListener

如果您利用 API（其他库和框架也支持这一点），您还可以在节点过时之前删除侦听器。该库还将确保即使应用程序在较旧的浏览器版本下运行也不会出现内存泄漏。

### 闭包

JavaScript 开发的一个关键方面是闭包：一个内部函数，可以访问外部（封闭）函数的变量。由于 JavaScript 运行时的实现细节，可能会通过以下方式泄漏内存：

```js
var theThing = null;
var replaceThing = function() {
  var originalThing = theThing;
  var unused = function() {
    if (originalThing)
      // a reference to 'originalThing'
      console.log('hi');
  };
  theThing = {
    longStr: new Array(1000000).join('*'),
    someMethod: function() {
      console.log('message');
    },
  };
};
setInterval(replaceThing, 1000);
```

一旦被调用，就会得到一个由大数组和一个新闭包组成的新对象 。然而，由变量（该变量是上一次调用中的变量）持有的闭包引用。要记住的是，一旦为同一父作用域中的闭包创建了闭包作用域，该作用域就是共享的。

在这种情况下，为闭包创建的作用域与 共享。 有对 的引用。即使从未使用过，也可以通过范围之外（例如，全球某个地方）使用。并且 as 与 共享闭包作用域，引用必须强制它保持活动状态（两个闭包之间的整个共享作用域）。这将阻止其收集。

在上面的示例中，为闭包创建的作用域与 共享，而 引用 。 可以通过范围之外使用，尽管从未使用过。未使用的引用要求它保持活动状态，因为与未使用的引用共享闭包作用域。

所有这些都可能导致相当大的内存泄漏。当上述代码段一遍又一遍地运行时，您可能会看到内存使用率的峰值。当垃圾回收器运行时，其大小不会缩小。将创建一个闭包的链接列表（在本例中其根是可变的），并且每个闭包作用域都前移对大数组的间接引用。

这个问题是由 Meteor 团队发现的，[他们有一篇很棒的文章](https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156)，非常详细地描述了这个问题。

### DOM 引用

在某些情况下，开发人员将 DOM 节点存储在数据结构中。假设您要快速更新表中几行的内容。如果将对每个 DOM 行的引用存储在字典或数组中，则将有两个对同一 DOM 元素的引用：一个在 DOM 树中，另一个在字典中。如果决定删除这些行，则需要记住使这两个引用都无法访问。

```js
var elements = {
  button: document.getElementById('button'),
  image: document.getElementById('image'),
};
function doStuff() {
  elements.image.src = 'http://example.com/image_name.png';
}
function removeImage() {
  // The image is a direct child of the body element.
  document.body.removeChild(document.getElementById('image'));
  // At this point, we still have a reference to #button in the
  //global elements object. In other words, the button element is
  //still in memory and cannot be collected by the GC.
}
```

当涉及到对 DOM 树中的内部或叶节点的引用时，必须考虑一个额外的注意事项。如果在代码中保留对表单元格（标记）的引用，并决定从 DOM 中删除该表，但保留对该特定单元格的引用，则可能会出现严重的内存泄漏。您可能认为垃圾回收器会释放除该单元格之外的所有内容。然而，情况并非如此。由于单元格是表的子节点，并且子级保留对其父级的引用，因此对表单元格的单个引用将使整个表保留在内存中
