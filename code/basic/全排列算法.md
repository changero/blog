---
title: 全排列算法
date: 2020-12-12
---

### 全排列算法

给定一个正整数 n，计算从`0到n-1`组成的列表的所有情况

```python
#! /usr/bin/python3
import datetime
starttime = datetime.datetime.now()

n = 8
list = [ i for i in range(0, n) ]
# 中间队列
queue = []
# 最后结果
result = []

for i in range(0, n):
  # 先将每一个作为第一位的可能情况添加到中间队列中
  # 也可以把这部分循环放到生成queue的地方
  # 比如： queue = [[i] for i in range(0,n)]
  queue.append([i]);
  # 循环判断队列是否为空，后面会判断每一种解法的长度是否等于n
  # 如果等于n表示得到正确解，加入到result中
  # 否则，加入到中间队列，等待下一次循环
  while len(queue):
    # 取出第一个求解
    res = queue.pop(0);
    for j in range(0,n):
      # 防止重复添加到当前解里面
      if list[j] not in res:
        # 复制解法为一个新解法，相当于深拷贝
        newRes = res[:];
        newRes.append(list[j]);
        if len(newRes) == n:
          # 求解完成
          print(newRes);
          result.append(newRes);
        else:
          queue.append(newRes);

print("一共有"+str(len(result))+"种解法")
endtime = datetime.datetime.now()
print("程序总耗时:"+ str((endtime - starttime).seconds))
```

使用 js 实现一版

```js
const length = 8;
const list = Array.from({ length }).map((_, index) => index);
const queue = list.map((index) => [index]);
const result = [];
console.time("cal");
while (queue.length) {
  const res = queue.shift();
  for (let i of list) {
    if (!res.includes(i)) {
      const newRes = [...res, i];
      if (newRes.length === length) {
        console.log(newRes);
        result.push(newRes);
      } else {
        queue.push(newRes);
      }
    }
  }
}
// node v10上面耗时2s+
// node v15上面耗时4s+????????
console.timeEnd("cal");
console.log(`一种有${result.length}种解法`);
```

测试下来，计算 9 阶全排列，共有 362880 种解法，在 python 下耗时 10s 不到的样子，nodejs 耗时 200s+.....

## n 皇后问题

全排列的计算结构可以用以计算 n 皇后问题，具体对应关系是：

对于一个全排列解法：[ 8, 7, 6, 0, 4, 1, 3, 5, 2 ]。表示的是第一行第八列，第二行第七列.....（难怪 n 皇后问题没开放 js 来做解法）

只需要比较新加入的数字不在已有数字的斜线上，具体表述为：

新加入的数字与行数之差不能与之前的数字与各自行数之差相等或互为相反数；

```python
#! /usr/bin/python3
import datetime
starttime = datetime.datetime.now()

n = 8
list = [ i for i in range(0, n) ]
# 中间队列
queue = []
# 最后结果
result = []

for i in range(0, n):
  # 先将每一个作为第一位的可能情况添加到中间队列中
  # 也可以把这部分循环放到生成queue的地方
  # 比如： queue = [[i] for i in range(0,n)]
  queue.append([i]);
  # 循环判断队列是否为空，后面会判断每一种解法的长度是否等于n
  # 如果等于n表示得到正确解，加入到result中
  # 否则，加入到中间队列，等待下一次循环
  while len(queue):
    # 取出第一个求解
    res = queue.pop(0);
    # 针对n=1的情况做处理
    if len(res) == n:
      result.append(cur);
    else:
      for j in range(0,n):
        # 防止重复添加到当前解里面
        if list[j] not in res:
          # 计算列与行之差，保证新加入的数据不会出现在前面数据的右下角
          diff1 = [ res[i] - i for i in range(0, len(res)) ];
          # 计算列与行之和，保证新加入的数据不会出现在前面数据的左下角
          diff2 = [ res[i]+i for i in range(0,len(res)) ]
          # list[j] - len(res)计算列与行之差
          # list[j] + len(res)计算列与行之和
          if (list[j] - len(res)) not in diff1 and (list[j] + len(res)) not in diff2:
            # 复制解法为一个新解法，相当于深拷贝
            newRes = res[:];
            newRes.append(list[j]);
            if len(newRes) == n:
              # 求解完成
              print(newRes);
              result.append(newRes);
            else:
              queue.append(newRes);

print("一共有"+str(len(result))+"种解法")
endtime = datetime.datetime.now()
print("程序总耗时:"+ str((endtime - starttime).seconds))
# 绘制皇后图
return [ [ '.'*col+"Q"+"."*(n-col-1)  for col in res ] for res in result ]
```
