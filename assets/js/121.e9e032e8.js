(window.webpackJsonp=window.webpackJsonp||[]).push([[121],{463:function(t,v,_){"use strict";_.r(v);var l=_(14),o=Object(l.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[t._v("浏览器的布局，就不得不提"),v("code",[t._v("table-lauout")]),t._v("这个属性，")]),t._v(" "),v("p",[v("strong",[t._v("auto布局模式的步骤")]),t._v("：")]),t._v(" "),v("p",[v("code",[t._v("table-layout: auto")]),t._v("是浏览器的默认布局形式，在这种形式下，布局将基于各单元格的内容。表格在每一单元格读取计算之后才会显示出来，速度很慢。")]),t._v(" "),v("p",[t._v("基于内容计算，就是按内容的宽度，策略如下：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("每一列的宽度，依据该列中的最大内容宽度作为最终宽度,如果该列第一行设置了宽度，就以设置的宽度和内容宽度的最大值作为宽度")])]),t._v(" "),v("li",[v("p",[t._v("table的宽度为所有列的宽度总和。如果table有设置宽度")]),t._v(" "),v("p",[t._v("a.如果宽度总和小于table的宽度，那么会将这个差值平均分配到每一个列上。")]),t._v(" "),v("p",[t._v("b. 如果宽度总和大于设置的宽度，就看列是否可以压缩，压缩的的最小状态，就是以列中内容最多的单元格为准，直到压缩到所有列都不能压缩了为止，或者压缩到表格的设置宽度。")])])]),t._v(" "),v("p",[t._v("基于以上，在设置好table宽度的情况下，就有可能因为内容而导致table被撑开的情况，比如连续数字、字母、字符等，就去找相应的方案。比如折行、或者显示省略号。")]),t._v(" "),v("p",[v("strong",[t._v("fixed布局模型的工作步骤")]),t._v("：")]),t._v(" "),v("p",[t._v("在这种模式下必须要设定table的宽度才能生效")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("width属性值不是auto的所有列元素会根据width值设置该列的宽度。")])]),t._v(" "),v("li",[v("p",[t._v("表首行中位于该列的单元格width，根据该单元格宽度设置此列的宽度。如果这个单元格跨多列，则宽度在这些列上平均分配。")])]),t._v(" "),v("li",[v("p",[t._v("在以上两步之后，如果列的宽度仍为auto，会自动确定其大小，使其宽度尽可能相等。此时，表的宽度设置为表的width值或列宽度之和(取其中较大者)。如果表格度大于其列宽总和，将二者之差除以列数，再把得到的这个宽度增加到每一列上。\n这种方法的速度很快，因为所有列宽都由表的第一行定义。首行后所有行中的单元格都根据首行所定义的列宽确定大小。后面这些行中的单元格不会改变列宽。这意味着为这些单元格指定的width值都会被忽略。")])])])])}),[],!1,null,null,null);v.default=o.exports}}]);