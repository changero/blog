(window.webpackJsonp=window.webpackJsonp||[]).push([[211],{569:function(t,e,_){"use strict";_.r(e);var v=_(14),n=Object(v.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("遇到公司电脑打不开的情况，满心欢喜以为加装一个 deepin，然后通过修复引导来完成 window 的配置，还可以顺手弄个双系统，结果哪想到 too young too sample。")]),t._v(" "),e("p",[t._v("于是乎，又一次不得不面对各种各样的名词，不知道什么意思和关联，反正跟着别人的教程盘就是了。")]),t._v(" "),e("p",[t._v("当然，最开始的时候，我还是按照自己所知道的来安装，首先为了要安装 deepin，需要单独分一个区出来，这是理所当然的。好在主硬盘上有 50G 的未分配\n。因为 U 盘使用的是 UEFI 安装，所以 bios 也要调整为支持通过 UEFI 启动。将硬盘分区格式调整为 GPT 格式，在 GPT 格式下，就没有激活分区的说法了。通过 U 盘，顺利的将 deepin 安装进了硬盘，但是启动的时候出现了错误，百度之后得到的答案是需要升级什么微码")]),t._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("apt")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" intel-microcode\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("但是这个时候电脑已经没有一个可以进入的系统了。只能回到家之后把硬盘拆下来通过移动盘位在自己的电脑上安装了。这里主要是记录一些安装过程中遇到的名字和系统引导启动的过程")]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("首先设置 biso 中的 2 个选项,"),e("code",[t._v("Secure boot: disabled")]),t._v("和"),e("code",[t._v("lanuch CMS: enable")]),t._v("。这两个选项是关闭安全启动和开启兼容模块，主要是不兼容 UEFI 的硬件。开了 SecureBoot 之后，主板会验证即将加载的 efi 文件的签名，如果开发者不是受信任的开发者，就会拒绝加载。比如 CloverX64.efi 就好像没有签名")]),t._v(" "),e("h2",{attrs:{id:"启动模式和硬盘格式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#启动模式和硬盘格式"}},[t._v("#")]),t._v(" 启动模式和硬盘格式")]),t._v(" "),e("p",[t._v("在 bios 中，有个选项"),e("code",[t._v("UEFI/Legacy")]),t._v("，"),e("a",{attrs:{href:"https://blog.csdn.net/z15732621736/article/details/49048779",target:"_blank",rel:"noopener noreferrer"}},[t._v("百度一下"),e("OutboundLink")],1),t._v("。发现，其实就是启动的方式不一样，使用 UEFI 启动速度更快。")]),t._v(" "),e("p",[t._v("顺便还引出了两种模式下对应的硬盘格式：")]),t._v(" "),e("p",[t._v("1、 在 Legacy 启动模式中，硬盘分区格式应该为 MBR 格式；")]),t._v(" "),e("p",[t._v("2、 在 UEFI 启动模式中，硬盘分区格式应该为 GUID（GPT）格式。")]),t._v(" "),e("p",[t._v("那么什么又是 MBR，什么又是 GPT。"),e("a",{attrs:{href:"https://blog.csdn.net/z15732621736/article/details/49046367",target:"_blank",rel:"noopener noreferrer"}},[t._v("点此查看"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("strong",[t._v("MBR")]),t._v("，主引导记录，是通过在硬盘的起始位置，写入的占据 64 个字节的分区表信息，而每一个分区信息都占据 16 个字节，也就是说这种模式下最多可以有 4 个分区。并且，每个分区最多 2T 的容量。分成的这 4 个分区也叫做主分区，如果想要拥有 4 个以上的分区，就只能通过扩展分区来完成，扩展分区也是主分区，这个时候分区信息就是 3 个主分区+1 个扩展分区。在分区表中只能有一个扩展分区，在扩展分区中，也有类似 MBR 结构的引导记录，去关联逻辑分区，理论上逻辑分区可以有无数个")]),t._v(" "),e("p",[e("strong",[t._v("GPT")]),t._v("，全局唯一标识分区表，是用来替代 BIOS 中的主引导记录分区表的，可以支持大于 2T 的分区。在 MBR 硬盘中，分区信息直接存储于主引导记录(MBR)中（主引导记录中还存储着系统的引导程序），但在 GPT 硬盘中，分区表的位置信息储存在 GPT 头中。出于兼容性考虑，硬盘的第一个扇区仍然用作 MBR，之后才是 GPT 头。GPT 磁盘分区样式支持最大卷为 18 EB（1EB = 1024*1024TB）。转换为 GPT 的时候可以创建两个隐藏分区，ESP 和 MSR。ESP 是 efi 系统分区用于保存引导文件，MSR 是微软的保留分区，用于安装操作系统。只有基于 UEFI 平台的主板才支持 GPT 分区引导启动。该分区用于采用了 EFI BIOS 的电脑系统，用来启动操作系统。分区内存放引导管理程序、驱动程序、系统维护工具等")]),t._v(" "),e("p",[t._v("现在知道了启动的模式，"),e("code",[t._v("UEFI + GPT")]),t._v("或者"),e("code",[t._v("BIOS + MBR")]),t._v("，都 2019 年了当然是选择前者")]),t._v(" "),e("p",[t._v("那它们分别是如何引导系统的呢")]),t._v(" "),e("h2",{attrs:{id:"bios-启动-mbr"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bios-启动-mbr"}},[t._v("#")]),t._v(" bios 启动 MBR")]),t._v(" "),e("p",[t._v("一句话概括：BIOS 只认识设备，不认识分区、不认识文件。")]),t._v(" "),e("blockquote",[e("p",[t._v("BIOS 启动的时候，按照 CMOS 设置里的顺序，挨个存储设备看：（此处不讨论 PXE 和光盘）\n这个存储设备的前 512 字节是不是以 0x55 0xAA 结尾？\n不是，那就跳过。找下一个设备。\n是的话，嗯，这个磁盘可以启动，加载这 512 字节里的代码，然后执行。\n执行之后，后面的事，几乎就跟 BIOS 没啥关系了。")])]),t._v(" "),e("p",[t._v("至于引导进入什么系统就是看写在这 512 字节的内容是谁家的代码了。")]),t._v(" "),e("ul",[e("li",[t._v("比如你装（或者重装）了 Windows，这里面就变成了 Windows 的启动代码。")]),t._v(" "),e("li",[t._v("比如你装（或者重装）了 Linux，这里面就会变成 Grub 的启动代码。")])]),t._v(" "),e("p",[t._v("顺便这 512 字节包含了 MBR 分区表的信息，而至于这个硬盘是怎么分区的，系统装在那个分区，跟 bios 没一点关系，bios 只要找到这个硬盘就行了，剩下的就是把这 512 字节的代码加载进内存来执行")]),t._v(" "),e("p",[t._v("阮老师解释"),e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2013/02/booting.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("MBR 的启动过程"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("img",{attrs:{src:"https://pic1.zhimg.com/80/v2-b9e4fc437c4cce5353f4def8a6584820_hd.jpg",alt:""}})]),t._v(" "),e("h2",{attrs:{id:"uefi-启动-gpt-硬盘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#uefi-启动-gpt-硬盘"}},[t._v("#")]),t._v(" UEFI 启动 GPT 硬盘")]),t._v(" "),e("p",[t._v("一句话概括，UEFI 认识设备，还认识设备 ROM，还认识分区表、认识文件系统以及文件。")]),t._v(" "),e("blockquote",[e("p",[t._v("UEFI 启动的时候，经过一系列初始化（SEC、CAR、DXE 什么的，SEC、CAR 你们不需要懂。下一节里会说 DXE 阶段是干嘛的）"),e("br"),t._v("\n然后按照设置里的顺序，找启动项。启动项分两种，设备启动项和文件启动项："),e("br"),t._v("\n·"),e("strong",[t._v("文件启动项")]),t._v("，大约记录的是某个磁盘的某个分区的某个路径下的某个文件。对于文件启动项，固件会直接加载这个 EFI 文件，并执行。类似于 DOS 下你敲了个 win.com 就执行了 Windows 3.2/95/98 的启动。文件不存在则失败。"),e("br"),t._v("\n·"),e("strong",[t._v("设备启动项")]),t._v("，大约记录的就是“某个 U 盘”、“某个硬盘”。（此处只讨论 U 盘、硬盘）对于设备启动项，UEFI 标准规定了默认的路径“\\EFI\\Boot\\bootX64.efi”。UEFI 会加载磁盘上的这个文件。文件不存在则失败。")])]),t._v(" "),e("p",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/31365115",target:"_blank",rel:"noopener noreferrer"}},[t._v("详细教程"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("UEFI 规范里，在 GPT 分区表的基础上，规定了一个 EFI 系统分区（EFI System Partition，ESP），ESP 要格式化成 FAT32，EFI 启动文件要放在“\\EFI<厂商>”文件夹下面。"),e("code",[t._v("\\EFI\\Boot\\bootX64.efi")]),t._v("文件指向谁就启动谁")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://pic4.zhimg.com/80/v2-4d5f4f0808f6af0c6319629bfe3a5b73_hd.jpg",alt:""}})])])}),[],!1,null,null,null);e.default=n.exports}}]);