---
title: 二叉堆
date: 2020-12-28
categories:
  - 算法
tags:
  - 二叉堆
---

## 什么是二叉堆

## python 实现

```python
#! /usr/bin/env python
class Heap:
  def __init__(self, max):
    self.max = max;
    self.data = [0];
    self.size = 0;

  def buildHeap(self, l, max):
    self.max = max
    self.data[1:] = l
    self.size = len(l)
    i = self.size // 2
    while i>=1:
      h.precolateDown(i)
      i-=1

  def printHeap(self):
    print('-'*20)
    print(h.max)
    print(h.data[1:])
    print(h.size)
    print('-'*20)
  def isFull(self):
    return self.max == self.size
  def insert(self,num):
    if(self.isFull()): return -1
    self.data.append(num)
    self.size+=1
    self.precolateUp(self.size)
  def precolateUp(self, index):
    value = self.data[index]
    current = index
    while current >= 2 and value < self.data[current//2]:
      self.data[current] = self.data[current//2]
      current = current // 2
    self.data[current] = value
  def removeHeap(self):
    num = self.data[0]
    least = self.data.pop()
    self.data[1] = least
    self.precolateDown(1)
    self.size = self.size -1
  def precolateDown(self, index):
    value = self.data[index]
    current = index
    while current * 2 <= self.size:
      left = self.data[current*2]
      right = 0xffff if current*2+1 > self.size else self.data[current*2+1]
      if left <value and left < right:
        self.data[current] = self.data[current*2]
        current = current * 2
      elif right < value and right < left:
        self.data[current] = self.data[current*2+1]
        current = current * 2 + 1
      else:
        break
    self.data[current] = value

def createHeap(max):
  return Heap(max)


if __name__ == '__main__':
  h = createHeap(50)
  # h.insert(5)
  # h.insert(10)
  # h.insert(20)
  # h.insert(50)
  # h.insert(3)
  # h.insert(18)
  # h.printHeap()
  # h.removeHeap()
  # h.printHeap()
  h.buildHeap([10, 50, 60, 5, 30, 20], 50)
  h.printHeap()
```

## C 语言实现

```C
#include <stdio.h>
#include <stdlib.h>

typedef int Elem;

struct heap {
  Elem *data;
  int max;
  int size;
};

typedef struct heap* Heap;


Heap createHeap(int max){
  Heap h;
  h = (Heap)malloc(sizeof(struct heap));
  if(!h) return NULL;
  h->data = (Elem*)malloc(sizeof(Elem)*(max+1));
  if(!h->data) return NULL;
  h->max = max;
  h->size = 0;
  return h;
}

void printHeap(Heap h){
  for(int i = 1; i<=h->size;i++){
    printf("%d ", h->data[i]);
  }
  printf("\n");
}

int isFull(Heap h){
  return h->size == h->max;
}

int isEmpty(Heap h){
  return h->size == 0;
}

void percolateUp(int k, Heap h){
  int x = h->data[k];
  h->data[0] = x;
  int i;
  for(i=k; i>1 && x < h->data[i/2]; i/=2){
    h->data[i] = h->data[i/2];
  }
  h->data[i] = x;
}

Elem getNode(int index, Heap h){
  if(index>h->size) return 0xffff;
  return h->data[index];
}
void percolateDown(int k, Heap h){
  if(isEmpty(h)) return;
  Elem x = h->data[k];
  int i = k;
  while(2*i<=h->size){
    Elem left = getNode(2*i, h);
    Elem right = getNode(2*i+1, h);
    if(left<right && left<x){
      h->data[i] = h->data[2*i];
      i = 2*i;
    }else if (right<x&&right<left){
      h->data[i] = h->data[2*i+1];
      i = i*2+1;
    }else if((x<left && x< right) ){
      // h->data[i] = x;
      break;
    }

  }
  h->data[i] = x;
}

int insertHeap(Elem x, Heap h){
  if(isFull(h)) return 0;
  h->data[++h->size] = x;
  percolateUp(h->size, h);
  return 1;
}

int removeHeap(Elem *px, Heap h){
  if(isEmpty(h)) return 0;
  *px = h->data[1];
  h->data[1] = h->data[h->size--];
  percolateDown(1, h);
  return 1;
}

Heap buildHeap(Elem *a, int size , int max){
  Heap h;
  h = createHeap(max);
  if(!h) return NULL;
  h->size=size;
  for(int i=1;i<=size;i++){
    h->data[i] = a[i-1];
  }
  for(int i = h->size/2; i>0;i--){
    percolateDown(i, h);
  }
  return h;
}

int main(){
  // Heap h = createHeap(10);

  // insertHeap(5, h);
  // insertHeap(10, h);
  // insertHeap(20, h);
  // insertHeap(15, h);
  // insertHeap(3, h);
  // insertHeap(99, h);
  // printHeap(h);
  // Elem *x;
  // removeHeap(x, h);
  // printf("%d \n", *x);
  // printHeap(h);

  Elem a[6] = { 10, 50, 60, 5, 30, 20 };
  Heap h;
  h = buildHeap(a, 6 ,50);
  printHeap(h);
}
```

通过 gcc 编译

> gcc heap.c -o heap

执行

> ./heap
