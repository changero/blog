(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{395:function(s,a,e){"use strict";e.r(a);var t=e(14),n=Object(t.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("一开始，是准备使用ubuntu中的常规方法去设置开机脚本，比如"),a("code",[s._v("update-rc.d")]),s._v("，或者设置"),a("code",[s._v("rc.local")]),s._v("文件等等方法，结果这些方法都一律失效。接着经过不屑的努力去google，发现一个博客上是这样描述的")]),s._v(" "),a("blockquote",[a("p",[s._v("在执行 update-rc.d 任务的时候，会先运行一下 /usr/sbin/policy-rc.d 任务。果返回值是 0，那么 OK，执行任务，如果返回值是 101，那么不好意思，任务不执行。事实上 Docker 在容器里面就直接返回了个 101，所以执行 update-rc.d 的时候根本没用。为了放行服务的自启动，我们需要修改一下这个脚本，看下面，我们只需要将原来的 exit 101 改成 exit 0 即可。")])]),s._v(" "),a("p",[s._v("结果发现还是不行")]),s._v(" "),a("p",[s._v("最终，才学习到原来是这样的")]),s._v(" "),a("blockquote",[a("p",[s._v("Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 systemd 去启动后台服务，容器内没有后台服务的概念")])]),s._v(" "),a("p",[s._v("所以，无论以那种方式去执行脚本，如果容器开启之后，进程跑完了，那容器也就停止了。所以关键不在于去启动脚本，而是怎么让进程挂起")]),s._v(" "),a("h3",{attrs:{id:"解决办法就是修改启动之后的执行命令-也就是cmd"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决办法就是修改启动之后的执行命令-也就是cmd"}},[s._v("#")]),s._v(" 解决办法就是修改启动之后的执行命令，也就是CMD")]),s._v(" "),a("p",[s._v("方法有两种：")]),s._v(" "),a("h4",{attrs:{id:"方法一"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法一"}},[s._v("#")]),s._v(" 方法一")]),s._v(" "),a("p",[s._v("在创建容器的时候指定")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[s._v("docker")]),s._v(" run -it -d "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("image"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" /bin/bash -c "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"file"')]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h4",{attrs:{id:"方法二"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法二"}},[s._v("#")]),s._v(" 方法二")]),s._v(" "),a("p",[s._v("通过DOckerfile来创建一个新的镜像")]),s._v(" "),a("p",[s._v("Dockerfile:")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("FROM imageName\n\nMAINTAINER youname<email>\n\nCMD node /opt/index.js\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("创建镜像")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[s._v("docker")]),s._v(" build -t imagesName2:tag "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("Dockerfile所在目录"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("这样就可以在创建容器的时候不需要手动指定启动脚本")]),s._v(" "),a("p",[s._v("e.g")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[s._v("docker")]),s._v(" run -it -d imagesName2:tag\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h4",{attrs:{id:"其他问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他问题"}},[s._v("#")]),s._v(" 其他问题")]),s._v(" "),a("p",[s._v("以上，都是在启动容器的时候直接执行node来创建服务，但是这种方法有一个缺点就是，当你再次通过"),a("code",[s._v("exec")]),s._v("命令进入到已启动的容器中的"),a("code",[s._v("/bin/bash")]),s._v("环境时，无法查看到启动容器时开启的服务，也就是说，这个时候服务是无法在容器创建之后手动停止或修改的")]),s._v(" "),a("p",[s._v("解决的办法是创建一个脚本去启动node程序，并让脚本最后进入"),a("code",[s._v("/bin/bash")]),s._v("环境")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token shebang important"}},[s._v("#! /bin/bash")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("cd")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("folder"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("npm")]),s._v(" start\n/bin/bash\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("注意最后的"),a("code",[s._v("/bin/bash")]),s._v(",这保证容器启动之后是停留在bash环境下，而不会因为进程结束，导致容器关闭。")]),s._v(" "),a("p",[s._v("另外，这里"),a("code",[s._v("npm start")]),s._v("，替换成"),a("code",[s._v("node index.js")]),s._v("的话，猜测可能会出现容器停留在node环境下，而不会进入bash，导致出现之前提到的问题.")]),s._v(" "),a("p",[s._v("实际上我采用了pm2来管理node程序，保证pm2执行完成以后，最终会进入bash环境")]),s._v(" "),a("p",[s._v("最后，只需要把之前的CMD改为执行这个脚本文件就可以了")])])}),[],!1,null,null,null);a.default=n.exports}}]);