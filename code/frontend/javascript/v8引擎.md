---
title: v8引擎
date: '2022-04-04 18:04:24'
categories:
  - javascript
tags:
  - js工作原理
lang: zh-cn
---

## 概述

**JavaScript 引擎**指的是执行 JavaScript 代码的程序或解释器。可以实现为标准解释器，也可以是以某种形式将 JavaScript 编译为字节码的实时编译器。以下是正在实现 JavaScript 引擎的流行项目列表：

|                                        解释器                                        |                                                                            github                                                                            | 是否开源 |                     备注                      |
| :----------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------------------------------------------------------------: | :------: | :-------------------------------------------: |
|          [V8 引擎](<https://en.wikipedia.org/wiki/V8_(JavaScript_engine)>)           |                           [![GitHub Repo stars](https://img.shields.io/github/stars/v8/v8?style=social)](https://github.com/v8/v8)                           |   开源   |          由 Google 开发，用 C++ 编写          |
|          [Rhino](<https://en.wikipedia.org/wiki/Rhino_(JavaScript_engine)>)          |                   [![GitHub Repo stars](https://img.shields.io/github/stars/mozilla/rhino?style=social)](https://github.com/mozilla/rhino)                   |   开源   | 由 Mozilla 基金会管理，开源，完全用 Java 开发 |
|   [SpiderMonkey](<https://en.wikipedia.org/wiki/SpiderMonkey_(JavaScript_engine)>)   |                                                     [仓库地址](https://hg.mozilla.org/mozilla-central/)                                                      |   开源   |     第一个 JavaScript 引擎， Firefox 使用     |
|            [JavaScriptCore](https://en.wikipedia.org/wiki/JavaScriptCore)            |                   [![GitHub Repo stars](https://img.shields.io/github/stars/WebKit/WebKit?style=social)](https://github.com/WebKit/WebKit)                   |   开源   |            由 Apple 为 Safari 开发            |
|                [KJS ](<https://en.wikipedia.org/wiki/KJS_(software)>)                |                                                         [仓库地址](https://anongit.kde.org/kjs.git)                                                          |   开源   |                  KDE 的引擎                   |
|    [Chakra （JScript9）](<https://en.wikipedia.org/wiki/Chakra_(JScript_engine)>)    |                                                     [仓库地址](https://hg.mozilla.org/mozilla-central/)                                                      |   开源   |               Internet Explorer               |
| [Chakra （JavaScript） ](<https://en.wikipedia.org/wiki/Chakra_(JavaScript_engine)>) |          [![GitHub Repo stars](https://img.shields.io/github/stars/chakra-core/ChakraCore?style=social)](https://github.com/chakra-core/ChakraCore)          |   开源   |                Microsoft Edge                 |
|        [Nashorn](<https://en.wikipedia.org/wiki/Nashorn_(JavaScript_engine)>)        |                                                                                                                                                              |          |           开源作为 OpenJDK 的一部分           |
|              [JerryScript ](https://en.wikipedia.org/wiki/JerryScript)               | [![GitHub Repo stars](https://img.shields.io/github/stars/jerryscript-project/jerryscript?style=social)](https://github.com/jerryscript-project/jerryscript) |   开源   |            是物联网的轻量级引擎。             |

## 为什么创建 V8 引擎？

由 Google 构建的 V8 引擎是开源的，并以 C++编写。该引擎在谷歌浏览器中使用。同时 Node.js 也采用该引擎作为 js 的解释器

<c-img src="https://miro.medium.com/max/1400/1*AKKvE3QmN_ZQmEzSj16oXg.png" />

<!-- more -->

V8 最初旨在提高 Web 浏览器中 JavaScript 执行的性能。为了提高运行速度，V8 将 JavaScript 代码转换为更有效的机器代码，而不是使用解释器。它通过实现 JIT（Just-In-Time）编译器在执行时将 JavaScript 代码编译为机器代码，与其他许多现代 JavaScript 引擎（如 SpiderMonkey 或 Rhino（Mozilla）的主要区别在于 V8 不产生字节码或任何中间代码。

### V8 曾经有两个编译器

在 V8 的 5.9 版本发布（今年早些时候发布）之前，引擎使用了两个编译器：

- full-codegen ： 一个简单且非常快速的编译器，可生成简单且相对较慢的机器代码。
- Crankshaft ： 一种更复杂的（实时）优化编译器，可生成高度优化的代码。

V8 引擎还在内部使用多个线程：

- 主线程执：获取代码，编译并执行
- 还有一个单独的线程用于编译，以便主线程可以在前者优化代码时继续执行
- 一个 Profiler 线程，它将告诉运行时我们花费大量时间在哪些方法上，以便 Crankshaft 可以优化它们
- 用于处理垃圾回收器扫描的几个线程

当第一次执行 JavaScript 代码时，V8 利用 full-codegen 直接将解析后的 JavaScript 转换为机器代码，而无需任何转换。这允许它非常快速地开始执行机器代码。请注意，V8 不会以这种方式使用中间字节码表示，从而消除了对解释器的需求。

当代码运行一段时间后，探查器线程已收集足够的数据来判断应优化哪种方法。

接下来，曲轴优化从另一个线程开始。它将 JavaScript 抽象语法树转换为称为 Hydrogen 的高级静态单赋值 （SSA） 表示形式，并尝试优化该 Hydrogen 图。大多数优化都是在此级别完成的。

### 内联

第一个优化是提前内联尽可能多的代码。内联是将调用站点（调用函数的代码行）替换为被调用函数的主体的过程。这个简单的步骤使以下优化更有意义。

<c-img src="https://miro.medium.com/max/1024/0*RRgTDdRfLGEhuR7U.png" />

### 隐藏类

JavaScript 是一种基于原型的语言：没有 Class，对象是使用克隆过程创建的。JavaScript 也是一种动态编程语言，这意味着在实例化对象后可以轻松地从对象中添加或删除属性。

大多数 JavaScript 解释器使用类似字典的结构（基于哈希函数）来存储对象属性值在内存中的位置。这种结构使得在 JavaScript 中检索属性的值比在 Java 或 C# 等非动态编程语言中检索属性的值在计算上更昂贵。在 Java 中，所有对象属性在编译之前都由固定的对象布局确定，并且不能在运行时动态添加或删除（好吧，C#具有动态类型，这是另一个主题）。因此，属性值（或指向这些属性的指针）可以作为连续缓冲区存储在内存中，每个缓冲区之间有固定的偏移量。偏移量的长度可以很容易地根据属性类型来确定，而这在 JavaScript 中是不可能的，因为属性类型可以在运行时更改。

由于使用字典在内存中查找对象属性的位置非常低效，因此 V8 改用了不同的方法：隐藏类。隐藏类的工作方式类似于 Java 等语言中使用的固定对象布局（类），只是它们是在运行时创建的。现在，让我们看看：

```js
function Point(x, y) {
  this.x = x;
  this.y = y;
}
var p1 = new Point(1, 2);
```

一旦"new Point（1， 2）"调用发生，V8 将创建一个名为"C0"的隐藏类。

<c-img src="https://miro.medium.com/max/1400/1*pVnIrMZiB9iAz5sW28AixA.png" />

尚未为 Point 定义任何属性，因此"C0"为空。

一旦第一个语句"this.x = x"被执行（在"Point"函数内部），V8 将创建第二个基于"C0"的名为"C1"的隐藏类。"C1"描述内存中可以找到属性 x 的位置（相对于对象指针）。在这种情况下，"x"存储在偏移量 0 处，这意味着当将内存中的点对象视为连续缓冲区时，第一个偏移量将对应于属性"x"。V8 还将使用"类转换"更新"C0"，该转换指出，如果将属性 "x" 添加到点对象，则隐藏类应从 "C0" 切换到 "C1"。下面点对象的隐藏类现在是"C1"。

<c-img src="https://miro.medium.com/max/1400/1*QsVUE3snZD9abYXccg6Sgw.png" />

_每次将新属性添加到对象时，旧的隐藏类都会使用到新隐藏类的转换路径进行更新。隐藏的类转换很重要，因为它们允许在以相同方式创建的对象之间共享隐藏类。如果两个对象共享一个隐藏类，并且向这两个对象添加了相同的属性，则转换将确保两个对象接收相同的新隐藏类及其附带的所有优化代码。_

当执行语句`this.y = y`时（同样，在 Point 函数内部，在 `this.x = x` 语句之后），将重复此过程。

创建了一个名为"C2"的新隐藏类，将类转换添加到"C1"中，指出如果将属性"y"添加到 Point 对象（已包含属性"x"），则隐藏类应更改为"C2"，并且 point 对象的隐藏类将更新为"C2"。

<c-img src="https://miro.medium.com/max/1400/1*spJ8v7GWivxZZzTAzqVPtA.png" />

隐藏的类转换取决于将属性添加到对象的顺序。看看下面的代码：

```js
function Point(x, y) {
  this.x = x;
  this.y = y;
}
var p1 = new Point(1, 2);
p1.a = 5;
p1.b = 6;
var p2 = new Point(3, 4);
p2.b = 7;
p2.a = 8;
```

现在，您假设对于 p1 和 p2，将使用相同的隐藏类和转换。嗯，不是真的。对于"p1"，首先将添加属性"a"，然后添加属性"b"。但是，对于"p2"，首先分配"b"，然后是"a"。因此，由于转换路径不同，"p1"和"p2"最终具有不同的隐藏类。在这种情况下，最好以相同的顺序初始化动态属性，以便可以重用隐藏类。

### 内联缓存

V8 利用另一种技术来优化动态类型语言，称为内联缓存。内联缓存依赖于这样一种观察结果，即对同一方法的重复调用往往发生在相同类型的对象上。可在[这里](https://github.com/sq/JSIL/wiki/Optimizing-dynamic-JavaScript-with-inline-caches)找到有关内联缓存的深入说明。

我们将介绍内联缓存的一般概念（以防您没有时间仔细阅读上面的深入解释）。

那么它是如何工作的呢？V8 维护在最近的方法调用中作为参数传递的对象类型的缓存，并使用此信息对将来将作为参数传递的对象类型做出假设。如果 V8 能够对将传递给方法的对象类型做出良好的假设，那么它可以绕过弄清楚如何访问对象属性的过程，而是使用以前查找对象的隐藏类中存储的信息。

那么，隐藏类和内联缓存的概念是如何关联的呢？每当对特定对象调用方法时，V8 引擎都必须对该对象的隐藏类执行查找，以确定用于访问特定属性的偏移量。在对同一隐藏类成功调用同一方法两次后，V8 省略了隐藏类查找，而只是将属性的偏移量添加到对象指针本身。对于该方法的所有将来调用，V8 引擎假定隐藏类未更改，并使用从以前的查找中存储的偏移量直接跳转到特定属性的内存地址。这大大提高了执行速度。

内联缓存也是同类型对象共享隐藏类如此重要的原因。如果您创建两个相同类型且具有不同隐藏类的对象（如我们在前面的示例中所做的那样），V8 将无法使用内联缓存，因为即使这两个对象属于同一类型，它们相应的隐藏类也会为其属性分配不同的偏移量。

<c-img src="https://miro.medium.com/max/1400/1*iHfI6MQ-YKQvWvo51J-P0w.png" />

这两个对象基本相同，但"a"和"b"属性的创建顺序不同。

### 编译为机器代码

一旦氢气图得到优化，曲轴就会将其降低到称为锂的较低级别表示。大多数 Lithium 实现都是特定于架构的。寄存器分配在此级别进行。

最后，锂被编译成机器代码。然后发生了其他一些事情，称为 OSR：堆栈上替换。在我们开始编译和优化一个明显长时间运行的方法之前，我们可能正在运行它。V8 不会忘记它只是慢慢地执行了什么，以优化的版本重新开始。相反，它将转换我们拥有的所有上下文（堆栈，寄存器），以便我们可以在执行过程中切换到优化版本。这是一项非常复杂的任务，请记住，在其他优化中，V8 最初内联了代码。V8 并不是唯一能够做到这一点的引擎。

有一些称为去优化的安全措施可以进行相反的转换，并在引擎做出的假设不再成立的情况下恢复为非优化代码。

### 垃圾回收

对于垃圾回收，V8 使用传统的标记和扫描的代际方法来清理旧一代。标记阶段应该停止 JavaScript 的执行。为了控制 GC 成本并使执行更加稳定，V8 使用增量标记：它不是遍历整个堆，尝试标记每个可能的对象，它只遍历堆的一部分，然后恢复正常执行。下一个 GC 停止将从上一个堆行走停止的位置继续。这允许在正常执行期间进行非常短的暂停。如前所述，扫描阶段由单独的线程处理。

随着 2017 年早些时候 V8 5.9 的发布，引入了新的执行管道。这个新的管道在实际的 JavaScript 应用程序中实现了更大的性能改进和显著的内存节省。

新的执行管道建立在 V8 的解释器 [Ignition](https://github.com/v8/v8/wiki/Interpreter) 和 V8 最新的优化编译器 [TurboFan](https://github.com/v8/v8/wiki/TurboFan) 之上。

您可以在[此处](https://v8project.blogspot.bg/2017/05/launching-ignition-and-turbofan.html)查看 V8 团队关于该主题的博客文章。

自从 V8 的 5.9 版问世以来，V8 不再使用全 codegen 和 Crankshaft（自 2010 年以来一直为 V8 提供服务的技术）用于 JavaScript 执行，因为 V8 团队一直在努力跟上新的 JavaScript 语言特性和这些特性所需的优化。

这意味着整个 V8 将具有更简单，更易于维护的架构。

<c-img src="https://miro.medium.com/max/1280/0*pohqKvj9psTPRlOv.png" />

这些改进只是一个开始。新的 Ignition 和 TurboFan 管道为进一步的优化铺平了道路，这些优化将提高 JavaScript 的性能，并在未来几年内缩小 V8 在 Chrome 和 Node.js 中的足迹。

最后，这里有一些关于如何编写优化良好，更好的 JavaScript 的提示和技巧。您可以从上面的内容中轻松获得这些内容，但是，为了您的方便，这里有一个摘要：

### 如何编写优化的 JavaScript

- 对象属性的顺序：始终以相同的顺序实例化对象属性，以便可以共享隐藏类以及随后优化的代码。
- 动态属性：在实例化后向对象添加属性将强制隐藏类更改，并减慢针对以前的隐藏类优化的任何方法的速度。相反，请在对象的构造函数中分配对象的所有属性。
- 方法：重复执行相同方法的代码将比仅执行一次许多不同方法的代码（由于内联缓存）运行得更快。
- 数组：避免使用键不是增量数字的稀疏数组。没有包含每个元素的稀疏数组是一个哈希表。此类数组中的元素访问成本更高。此外，尽量避免预先分配大型数组。最好边走边成长。最后，不要删除数组中的元素。它使键稀疏。
- 标记值：V8 表示具有 32 位的对象和数字。它使用一个位来知道它是一个对象（标志 = 1）还是一个称为 SMI（SMall 整数）的整数（标志 = 0），因为它有 31 位。然后，如果数值大于 31 位，V8 会将该数字装箱，将其转换为双精度值，并创建一个新对象以将数字放入其中。尽可能尝试使用 31 位有符号的数字，以避免对 JS 对象执行代价高昂的装箱操作。

我们在 SessionStack 尝试遵循这些最佳实践来编写高度优化的 JavaScript 代码。原因是，一旦将 SessionStack 集成到生产 Web 应用程序中，它就会开始记录所有内容：所有 DOM 更改、用户交互、JavaScript 异常、堆栈跟踪、失败的网络请求和调试消息。
使用 SessionStack，您可以将 Web 应用中的问题重播为视频，并查看用户发生的一切。所有这些都必须在不影响 Web 应用性能的情况下进行。

有一个免费计划允许你[免费入门](https://www.sessionstack.com/solutions/developers/?utm_source=medium&utm_medium=blog&utm_content=the-v8-engine)。

## 资源

[原文地址](https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e)

- [https://docs.google.com/document/u/1/d/1hOaE7vbwdLLXWj3C8hTnnkpE0qSa2P--dtDvwXXEeD0/pub](https://docs.google.com/document/u/1/d/1hOaE7vbwdLLXWj3C8hTnnkpE0qSa2P--dtDvwXXEeD0/pub)
- [https://github.com/thlorenz/v8-perf](https://github.com/thlorenz/v8-perf)
- [http://code.google.com/p/v8/wiki/UsingGit](http://code.google.com/p/v8/wiki/UsingGit)
- [http://mrale.ph/v8/resources.html](http://mrale.ph/v8/resources.html)
- [https://www.youtube.com/watch?v=UJPdhx5zTaw](https://www.youtube.com/watch?v=UJPdhx5zTaw)
- [https://www.youtube.com/watch?v=hWhMKalEicY](https://www.youtube.com/watch?v=hWhMKalEicY)
