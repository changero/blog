---
title: 运行时
date: '2022-04-03 17:47:59'
categories:
  - javascript
tags:
  - js工作原理
lang: zh-cn
---

## 引擎、运行时和调用堆栈的概述

随着 JavaScript 变得越来越流行，团队正在利用其堆栈中许多级别的支持 - 前端，后端，混合应用程序，嵌入式设备等等。

这篇文章旨在深入挖掘 JavaScript 及其实际工作原理的系列文章中的第一篇：我们认为，通过了解 JavaScript 的构建块以及它们如何协同工作，将能够编写出更好的代码和应用程序

如果项目变得如此依赖 JavaScript，这意味着开发人员必须利用语言和生态系统提供的所有内容，对内部结构有越来越深的理解，以便构建令人惊叹的软件。

## 概述

几乎每个人都听说过 V8 引擎这个概念，大多数人都知道 JavaScript 是单线程的，或者它使用的是回调队列。在这篇文章中，我们将详细介绍所有这些概念，并解释 JavaScript 的实际运行方式。通过了解这些详细信息，您将能够编写出更好的，无阻塞的应用程序，这些应用程序可以正确利用提供的 API。

## js 引擎

JavaScript 引擎的一个流行例子是谷歌的 V8 引擎。V8 引擎再 Node 和 Chrome 中使用，下面是一个非常简化的视图

<!-- more -->

<c-img src="https://miro.medium.com/max/1400/1*OnH_DlbNAPvB9KLxUCyMsA.png" />

引擎由两个主要组件组成：

1. 堆内存：这是内存分配发生的地方
2. 堆栈：这是代码执行时堆栈帧所在的位置

### 运行时

浏览器中有一些 API 几乎被任何 JavaScript 开发人员使用过（例如"setTimeout"）。但是，这些 API 不是由引擎提供的。

那么，它们来自哪里呢？

事实证明，现实情况要复杂一些。

<c-img src='https://miro.medium.com/max/1400/1*4lHHyfEhVB0LnQ3HlhSs8g.png' />

我们有那些叫做 Web API 的东西，它们是由**浏览器**提供的，比如 DOM，AJAX，setTimeout 等等。

然后，我们有了接下来的**事件循环**和**回调队列**。

### 堆栈

JavaScript 是一种单线程编程语言，这意味着它只有一个单一的调用堆栈。因此，它同一事件只做一件事。

_调用堆栈是一种数据结构，它基本上记录了我们在程序中的位置_。如果我们单步执行一个函数，我们将其放在堆栈的顶部。如果我们从函数返回，我们会弹出堆栈的顶部。这就是堆栈可以执行的所有操作。

看下面一个例子:

```js
function multiply(x, y) {
  return x * y;
}
function printSquare(x) {
  var s = multiply(x, x);
  console.log(s);
}
printSquare(5);
```

当引擎开始执行此代码时，调用堆栈是空的。之后，步骤如下：

<c-img src="https://miro.medium.com/max/1400/1*Yp1KOt_UJ47HChmS9y7KXw.png" />

调用堆栈中的每个条目称为**堆栈帧**。

这正是引发异常时堆栈跟踪的构造方式 - 它基本上是异常发生时调用堆栈的状态。请看下面的代码：

```js
function foo() {
  throw new Error('SessionStack will help you resolve crashes :)');
}
function bar() {
  foo();
}
function start() {
  bar();
}
start();
```

如果在 Chrome 中执行此操作（假设此代码位于名为 foo.js 的文件中），则会生成以下堆栈跟踪：

<c-img src="https://miro.medium.com/max/1014/1*T-W_ihvl-9rG4dn18kP3Qw.png" />

**栈溢出**——当你的函数调用次数超过调用堆栈的大小时候就会发生，比如：递归调用

```js
function foo() {
  foo();
}
foo();
```

当引擎开始执行此代码时，它首先调用函数"foo"。但是，此函数是递归的，并且在没有任何终止条件的情况下开始调用自身。因此，在执行的每一步中，相同的函数都会一遍又一遍地添加到调用堆栈中。它看起来像这样：

<c-img src="https://miro.medium.com/max/1400/1*AycFMDy9tlDmNoc5LXd9-g.png" />

于是浏览器将显示如下的报错信息：

<c-img src="https://miro.medium.com/max/772/1*e0nEd59RPKz9coyY8FX-uw.png" />

在单个线程上运行代码可能非常容易，因为您不必处理多线程环境中出现的复杂场景，例如死锁。

### 并发和事件循环

当您在调用堆栈中有需要大量时间才能处理的函数调用时，会发生什么情况？例如，假设您想在浏览器中使用 JavaScript 进行一些复杂的图像转换。

你可能会问 - 这样会有什么问题？问题在于，调用栈有要执行的功能，因此浏览器实际上无法执行任何其他操作 - 它被阻止了。浏览器线程与 js 的执行线程是互斥的。

这意味着浏览器无法渲染，无法运行任何其他代码。如果你想要在你的应用中使用漂亮的流畅 UI，这会产生问题。

这不是唯一的问题。一旦您的浏览器开始处理调用堆栈中的许多任务，它可能会在很长一段时间内停止响应。大多数浏览器通过引发错误来采取措施，询问您是否要终止网页。

<c-img src="https://miro.medium.com/max/924/1*WlMXK3rs_scqKTRV41au7g.jpeg" />

那么，我们如何在不阻塞 UI 并使浏览器无响应的情况下执行繁重的代码呢？

解决方案是**异步回调**。

[原文连接](https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf)
